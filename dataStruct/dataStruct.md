# 数据结构笔记

## 数据结构中最重要的是  效率，牺牲时间或空间来提升算法效率

## 1.绪论

### 1.算法

#### 1.1算法基本概念

算法是对求解问题特定步骤的一种描述。

#### 1.2算法的5大特性

1. 有穷性：一个算法必须总在执行完有穷步之后结束，且每一步都可以在有穷时间内完成
2. 确定性：对于相同的输入只能得到相同的输出
3. 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次实现
4. 输入：一个算法有一个或多个输入
5. 输出：一个算法有一个或多个输出

#### 1.3."好算法"的特性

1. 正确性：
2. 可读性
3. 健壮性
4. 高效率与低存储需求

### 2.时间复杂度 O(n)

#### 2.1 概念：事前预估算法时间开销T(n)与问题规模n之间的关系

2.2 如何计算：在分析一段代码的时间复杂度的时候，只需要关注循环执行次数最多的那段代码

1. 加法法则：代码总的复杂度等于量级最大的那段代码的复杂度
2. 嵌套法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

2.3常见时间复杂度及关系

O(1) < O($log2^N$) < O(n) < O($nlog2^N$) < O($n^2$) < O($n^3$) < O(n!) < O($n^n$)

常对幂指阶

2.4三种常见的时间复杂度

1. 最好时间复杂度：最好情况下，执行算法的时间复杂度
2. 最坏时间复杂度：最坏情况下，执行算法的时间复杂度
3. 平均时间复杂度：加权平均复杂度或者期望时间复杂度



## 线性表

### 1.定义：具有相同数据类型的n个数据元素的有限序列

### 2.基本操作：

- initList(&L) :初始化表
- DestroyList(&L) :销毁操作
- ListInsert(&L,i,e):插入操作
- ListDelete(&L,i,&e):删除操作
- LocateElem(&L,e):按值查找
- GetElem(&L,i):按位查找

### 3. 顺序存储结构(顺序表)

3.1定义：用顺序存储的方式实现线性表的顺序存储，逻辑上相邻的数据元素在物理位置上也相邻

3.2时间复杂度分析

1. 查找操作、更改操作：可以通过data[i]直接访问到待查找元素，时间复杂度O(1)

2. 增加操作、删除操作：在顺序存储中，相邻的数据元素之间有着逻辑关系，因此，插入或者删除一个元素，意味着加入节点之后的所有数据元素都要向后或者向前移动一个位置，因此有三种情况讨论

   - 最坏时间复杂度：增加/删除表头元素，顺序表中所有元素都要移动，复杂度O(n)

   - 最好时间复杂度：增加/删除表尾元素，顺序表中元素都不需要移动，复杂度O(1)

   - 平均时间复杂度：在不确定移动位置的情况下，计算加权概率复杂度，即

     i =1，移动n-1，概率为 $1/n$

     i =2，移动n-3，概率为 $1/n$

     i =n,移动0次，概率为 $1/n$

     平均循环次数为：((n-1) + (n -2) + ... + 1) *  $1/n$ =  $(n(n-1)/2)*(1/n)$ =(n-1)/2,即时间复杂度为O((n-1)/2) = O(n)

3. 相关代码实现：

#### 4.链式存储结构

4.1 单链表定义：单链表通过一组任意的存储单元来存储线性表中的数据元素，不需要使用地址连续的存储单元，因此它不要求在逻辑上相邻的两个元素在物理位置上也相邻

4.2 单链表定义代码:

4.2.1 方式一：

```C
struct LNode{
  int data;
  struct LNode* next； 
}

typedef struct LNode LNode;
typedef struct LNode *LinkList;
```

4.2.1 方式二：

```c
typedef struct LNode{
  int data;
  struct LNode *next;
}LNode,*LinkList;
```

4.3 单链表头节点两种实现

4.3.1 不带头结点

​	头指针指向链表第一个数据节点。空表判断 `L == NULL`

4.3.2 带头结点(推荐使用)

​	头指针指向头节点，头节点数据域不存储信息，指针域指向链表第一个节点。空表判断 `L->next == NULL`

4.4 单链表插入操作

​	相较于带结点的链表插入，不带头节点的链表需要对插入到第一个元素位置的情况做处理，后续的操作处理都是一样的

​	对于单链表，每一个节点只知道后继节点的位置，对于前去节点的位置并不知晓，如果需要在某一个节点的前边插入一个新的节点，很容易想到使用双向链表，对于单链表也可以实现

​	需求：在p节点的前边新增一个A节点

​	方法实现：新建一个新节点，将新节点插入到P节点后，将p节点的data域信息复制到新节点数据域中，随后将A节点数据域信息复制到P节点信息域中，完成偷梁换柱，同理，若要删除p节点前的一个节点，可以标定p节点与p节点的下一个节点q，将q节点信息域数据复制到p节点信息域，p指向q的下一个节点，删除q节点，此类操作，时间复杂度均为O(1)

注：使用malloc生成一个节点时，要将数据域置空，养成好习惯

4.5单链表创建

1. 头插法:   新建链表节点时，将所有的元素节点都插入到链表头部的一种方式

   重要应用：链表的逆置(将链表元素从头至尾顺序调换一下)

   解决思路：去除表尾数据元素采用头插法插入到链表表头。

2. 尾插法：新建链表节点时，将所有的元素节点都插入到链表尾部的一种方式

   需要设置一个指向表尾节点的指针，否则循环查找，找到表尾后在进行表尾插入时间复杂度太高了 O($n^2$)

   - 插入第1个节点，循环0次

   - 插入第2个节点，循环1次

   - 插入第3个节点，循环2次

   - 插入第4个节点，循环3次

   - 插入第5个节点，循环4次

   - 插入第n个节点，循环(n-1)次

     ​

   ​





