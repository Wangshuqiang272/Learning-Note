# FreeRTOS知识点梳理

## 1.vTaskStartScheduler() 调度过程

### 1.创建空闲任务


​		注：空闲任务是为了在所有任务执行结束后，删除存放在待删除列表中的任务

1.任务创建过程分析

1. 创建TCB任务控制块以及任务栈空间

   ​	首先需要根据配置文件确定栈空间增长方向(通常系统中是向下增长的)

   ```c

   // 小于0是向下增长 大于0是向上增长
   #define portSTACK_GROWTH			( -1 )
   ```

   ​	栈结构具有一个开口方向，在内存中可以向上增长或者向下增长，然而，对于使用malloc从堆中分配空间来说，先申请的空间在低地址，TCB块与栈都需要malloc，因此需要避免栈的增长方向是朝向TCB控制块的方向从而引起覆盖TCB控制块的问题，由此。

   ​	**对于向上增长的栈，需要先申请TCB控制块的空间再申请栈空间**

   ​	**对于向下增长的栈，需要先申请栈空间再申请TCB控制块空间**

2. 根据形参初始化任务控制块

   1. 如果开启了堆栈使用检查功能，则在初始化的时候需要将栈空间内数据全部初始化为0xA5，供后续检查使用堆栈情况

   2. **确定栈顶指针位置**

      ​	根据配置文件中确定栈增长方向，继而确认栈顶指针地址。示意图如下：

      ```c
      // 栈向下增长演示  pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);

      // 					    |--------栈底-------|  高地址  <----pxTopOfStack 要指向这里才能向下增长，随着数据入栈栈顶指针向下增长
      // 						|                  |	
      // 						|                  |	
      // 						|                  |	
      // 						|                  |	|
      // 						|                  |	|
      // 						|                  |	|
      // 						|                  |	|
      // 						|                  |	
      // 						|                  |
      // 						|                  |
      //    malloc函数返回地址-->|                  |  低地址

      // 栈向上增长演示   pxTopOfStack = pxNewTCB->pxStack;

      // 					    |                  |  高地址  
      // 						|                  |	
      // 						|                  |	
      // 						|                  |	
      // 						|                  |	|
      // 						|                  |	|
      // 						|                  |	|
      // 						|                  |	|
      // 						|                  |	
      // 						|                  |
      // 						|                  |
      //   malloc函数返回地址--> |--------栈底-------|  低地址  <----pxTopOfStack 要指向这里才能向上增长，随着数据入栈栈顶指针向上增长	
      ```

   3. 将形参中 pcName 利用for循环赋值给任务控制块结构体中pcTaskName

      - 宏值决定赋值总数 configMAX_TASK_NAME_LEN 通常为16个字符
      - 当遇到形参中NULL时停止赋值操作

   4. 将形参中 uxPriority 赋值给任务控制块结构体中uxPriority

      1. 当形参uxPriority数值大于宏值设定的最大值时，默认设置为最大值-1

   5. 初始化任务控制块中状态列表，以及事件列表

   6. 初始化任务栈信息，初始化后堆栈信息如下：

      ```c
      // 					    |------栈顶--NULL--|  高地址  
      // 						|        NULL      |	
      // 						|        NULL      |	
      // 						|        0x1F      |	
      // 						|   回调函数地址    |	   |   R15 PC程序计数器
      // 						| 函数调用返回地址  |	 |   R14 链接寄存器
      // 						|        xx        |	|
      // 						|        xx        |	|   R12通用寄存器
      // 						|        xx        |    |	
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |
      // 						|        xx        |    |    R0通用寄存器
      // 						|        xx        |
      // 						|        xx        |
      // 						|                  |
      // 						|                  |
      // 						|                  |-->初始化函数返回栈地址
      // 						|        ...       |
      //                        |--------栈底------|  低地址 	
      ```

3. 将新建任务添加到就绪列表中

   1. 将全局变量**uxCurrentNumberOfTasks**加一，该变量用于缓存当前系统中的任务数量
   2. 判断pxCurrentTCB变量是否被复制
      1. 当前pxCurrentTCB变量为空（将当前任务控制块指针赋值给pxCurrentTCB）
         1. 当前没有任务被创建，此时需要初始化各个列表(就序列表、阻塞列表等等)
         2. 当前所有任务都处于阻塞态，继续执行
      2. 当前pxCurrentTCB变量不为空
         1. 系统未进行调度，则将创建的最高优先级任务赋值给变量pxCurrentTCB
   3. 判断当前调度器是否开始调度
      1. 系统开始调度后判断当前正在运行任务优先级与新创建的任务优先级那个高，新创建的任务优先级高，则执行高任务优先级

4. 任务创建成功，返回成功值

### 2.开启系统任务调度



## 2.任务删除过程分析(vTaskDelete(xTaskToDelete))

1. **通过待删除任务句柄获取任务控制块**（就是将任务句柄指针由void*强转成TCB_t）

2. **将待删除任务从状态列表中删除**

   ​	涉及双向链表删除节点操作（数据结构知识）以及任务列表项指向空值

3. 判断该任务是否在等待事件（任务事件列表项不为空）

   ​	不为空时直接从列表项中删除，不等了

4. 判断待删除任务是否为当前正在运行的任务

   1. 删除当前运行的任务

      ​	这种情况下无法直接删除，因为删除任务时需要将任务的堆栈以及任务控制块信息一同删除掉，否则会内存泄露，然而，当前正在运行这个任务，直接将堆栈删除的话系统会崩溃的，因此需要将该任务存起来，等有时间之后在进行删除。FreeRTOS是将其放到待删除列表中等待，在空闲任务中将该任务删除。

   2. 删除的任务不是当前任务

      - 全局任务总数-1

      - 删除任务控制块空间，free掉TCB空间以及堆栈空间，**注意：要先释放堆栈空间，再释放TCB空间，先释放TCB空间的话就找不到堆栈空间地址，就泄露了呀**

      - 更新下一次解除阻塞最近时间

         这里需要更新时间主要有两点原因。

         ​	1.如果待删除任务是等待解阻塞列表中最近的一个任务，那么删除之后，需要重新计算，防止系统等待一个已经被删除的任务解除阻塞。

         ​	2.如果待删除任务处于阻塞状态，被删除后，如果不更新时间，可能导致调度器在后续的任务解阻塞时访问无效的或已被删除的任务信息，从而引发错误或崩溃。

5. 若待删除任务是当前正在执行的任务，则调用一次任务切换




## 3.任务挂起函数分析（vTaskSuspend（xTaskToSuspend））

1. 获取待挂起任务的任务控制块
   - 参数NULL表示将当前正在运行的任务挂起
   - 不为空参数标识将特定任务挂起








