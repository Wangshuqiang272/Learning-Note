# Linux环境下编译动态库与静态库

## 1. 静态库编译

### 1. 静态库特点：

​		使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件 。因此生成的可执行文件较大，同时，如果需要升级会很麻烦，需要重新链接并发送给用户。

### 2.准备文件

- 入口函数源文件 如 test.c
- 接口源文件 如 packet.c
- 接口库文件 如 packet.h

### 3.编译过程

1.将接口源文件编译为目标文件

```bash
gcc -c packet.c    #得到packet.o
```

2.利用目标文件生成库文件

```bash
ar -vcr libpacket.a packet.o #注意 生成的库文件名称一定是以 lib 开头，结尾为.a
```

3.利用静态库文件生成可执行文件

```bash
gcc test.c -L . -lpacket -o test # -L 表示在自己规定的路径中搜索库文件 -l 表示编译时需要用到的库 -o 规定了生成的可执行文件的名称
```

​		

## 2.动态库编译

### 1.动态库特点：

​		与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。可执行文件较小，对于升级兼容性较高。

### 2.准备文件

- 入口函数源文件 如 test.c
- 接口源文件 如 packet.c
- 接口库文件 如 packet.h

### 3.编译过程

1.将源文件编译为库文件

```bash
	# -fPIC表示是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置
	# -shared作用是告诉编译器生成一个动态链接库
	#动态库通常是以lib开头，以.so结尾的文件
	gcc packet.c -fPIC -shared -o libpacket.so
```

2.将动态库文件放到系统能找的地方如 /usr/lib文件夹下

```bash
sudo cp libpacket.so /usr/lib
```

3.利用动态库生成可执行文件

```bash
gcc test.c -lfun -o test
```

